{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5da20792-f88a-407f-a531-9c4103c49be2",
   "metadata": {},
   "outputs": [],
   "source": [
    "import geopandas\n",
    "import pandas as pd\n",
    "from osgeo import ogr,gdal\n",
    "import os\n",
    "import numpy \n",
    "from tqdm import tqdm\n",
    "from shapely.wkb import loads\n",
    "import pygeos\n",
    "import matplotlib.pyplot as plt\n",
    "import openpyxl\n",
    "\n",
    "gdal.SetConfigOption(\"OSM_CONFIG_FILE\", \"osmconf.ini\")\n",
    "\n",
    "def query_b(geoType,keyCol,**valConstraint):\n",
    "    \"\"\"\n",
    "    This function builds an SQL query from the values passed to the retrieve() function.\n",
    "    Arguments:\n",
    "         *geoType* : Type of geometry (osm layer) to search for.\n",
    "         *keyCol* : A list of keys/columns that should be selected from the layer.\n",
    "         ***valConstraint* : A dictionary of constraints for the values. e.g. WHERE 'value'>20 or 'value'='constraint'\n",
    "    Returns:\n",
    "        *string: : a SQL query string.\n",
    "    \"\"\"\n",
    "    query = \"SELECT \" + \"osm_id\"\n",
    "    for a in keyCol: query+= \",\"+ a  \n",
    "    query += \" FROM \" + geoType + \" WHERE \"\n",
    "    # If there are values in the dictionary, add constraint clauses\n",
    "    if valConstraint: \n",
    "        for a in [*valConstraint]:\n",
    "            # For each value of the key, add the constraint\n",
    "            for b in valConstraint[a]: query += a + b\n",
    "        query+= \" AND \"\n",
    "    # Always ensures the first key/col provided is not Null.\n",
    "    query+= \"\"+str(keyCol[0]) +\" IS NOT NULL\" \n",
    "    return query \n",
    "\n",
    "\n",
    "def retrieve(osm_path,geoType,keyCol,**valConstraint):\n",
    "    \"\"\"\n",
    "    Function to extract specified geometry and keys/values from OpenStreetMap\n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region \n",
    "        for which we want to do the analysis.     \n",
    "        *geoType* : Type of Geometry to retrieve. e.g. lines, multipolygons, etc.\n",
    "        *keyCol* : These keys will be returned as columns in the dataframe.\n",
    "        ***valConstraint: A dictionary specifiying the value constraints.  \n",
    "        A key can have multiple values (as a list) for more than one constraint for key/value.  \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all columns, geometries, and constraints specified.    \n",
    "    \"\"\"\n",
    "    driver=ogr.GetDriverByName('OSM')\n",
    "    data = driver.Open(osm_path)\n",
    "    query = query_b(geoType,keyCol,**valConstraint)\n",
    "    sql_lyr = data.ExecuteSQL(query)\n",
    "    features =[]\n",
    "    # cl = columns \n",
    "    cl = ['osm_id']\n",
    "    \n",
    "    \n",
    "    for a in keyCol: cl.append(a)\n",
    "    if data is not None:\n",
    "        for feature in sql_lyr:\n",
    "            try:\n",
    "                if feature.GetField(keyCol[0]) is not None:\n",
    "                    shapely_geo = pygeos.from_wkt(feature.geometry().ExportToWkt())\n",
    "                    if shapely_geo is None:\n",
    "                        continue\n",
    "                    # field will become a row in the dataframe.\n",
    "                    field = []\n",
    "                    for i in cl: field.append(feature.GetField(i))\n",
    "                    field.append(shapely_geo)   \n",
    "                    features.append(field)\n",
    "            except:\n",
    "                print(\"WARNING: skipped OSM feature\")\n",
    "      \n",
    "    cl.append('geometry')                   \n",
    "    if len(features) > 0:\n",
    "        return geopandas.GeoDataFrame(features,columns=cl) #,crs={'init': 'epsg:4326'}\n",
    "    else:\n",
    "        print(\"WARNING: No features or No Memory. returning empty GeoDataFrame\") \n",
    "        return geopandas.GeoDataFrame(columns=['osm_id','geometry']) #,crs={'init': 'epsg:4326'}\n",
    "\n",
    "def landuse(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract land-use polygons from OpenStreetMap    \n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region \n",
    "        for which we want to do the analysis.        \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique land-use polygons.    \n",
    "    \"\"\"    \n",
    "    return(retrieve(osm_path,'multipolygons',['landuse']))\n",
    "\n",
    "def buildings(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract building polygons from OpenStreetMap    \n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region \n",
    "        for which we want to do the analysis.        \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique building polygons.    \n",
    "    \"\"\"\n",
    "    return retrieve(osm_path, 'multipolygons',['building','amenity'])\n",
    "\n",
    "def roads(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract road linestrings from OpenStreetMap  \n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region \n",
    "        for which we want to do the analysis.        \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique road linestrings.\n",
    "    \"\"\"   \n",
    "    return retrieve(osm_path,'lines',['highway']) \n",
    " \n",
    "#def railway(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract railway linestrings from OpenStreetMap   \n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region \n",
    "        for which we want to do the analysis.       \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique land-use polygons.\n",
    "    \"\"\" \n",
    "    #return retrieve(osm_path,'lines',['railway','service'],**{\"service\":[\" IS NOT NULL\"]})\n",
    "\n",
    "def railway(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract railway linestrings from OpenStreetMap\n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region \n",
    "        for which we want to do the analysis.       \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique land-use polygons.\n",
    "    \"\"\" \n",
    "    return retrieve(osm_path,'lines',['railway','service'])\n",
    "\n",
    "def train_stations(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract big communication tower nodes from OpenStreetMap. See detailed information big communication towers: https://wiki.openstreetmap.org/wiki/Tag:man_made%3Dcommunications_tower   \n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region for which we want to do the analysis.       \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique big communication tower nodes.\n",
    "    \"\"\"   \n",
    "    \n",
    "    return (retrieve(osm_path,'points',['railway', 'name'],**{'railway':[\"='station'\"]}))\n",
    "            #(retrieve(osm_path,'points',['railway'],**{'railway':[\"='station'\"]}))\n",
    "            #(retrieve(osm_path,'points',['man_made'],**{'man_made':[\"='communications_tower'\"]})).rename(columns={'man_made': 'asset'})\n",
    "\n",
    "def subway_stations(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract big communication tower nodes from OpenStreetMap. See detailed information big communication towers: https://wiki.openstreetmap.org/wiki/Tag:man_made%3Dcommunications_tower   \n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region for which we want to do the analysis.       \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique big communication tower nodes.\n",
    "    \"\"\"   \n",
    "    \n",
    "    return (retrieve(osm_path,'points',['railway', 'name'],**{'railway':[\"='subway_entrance'\"]}))     # useless\n",
    "\n",
    "def tram_stations(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract big communication tower nodes from OpenStreetMap. See detailed information big communication towers: https://wiki.openstreetmap.org/wiki/Tag:man_made%3Dcommunications_tower   \n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region for which we want to do the analysis.       \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique big communication tower nodes.\n",
    "    \"\"\"   \n",
    "    \n",
    "    return (retrieve(osm_path,'points',['railway', 'name'],**{'railway':[\"='tram_stop'\"]}))\n",
    "\n",
    "def ferries(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract road linestrings from OpenStreetMap\n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region \n",
    "        for which we want to do the analysis.\n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique road linestrings.\n",
    "    \"\"\"\n",
    "    return retrieve(osm_path,'lines',['route'],**{\"route\":[\"='ferry'\",]})\n",
    "\n",
    "def electricity(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract railway linestrings from OpenStreetMap    \n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region \n",
    "        for which we want to do the analysis.        \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique land-use polygons.   \n",
    "    \"\"\"    \n",
    "    return retrieve(osm_path,'lines',['power','voltage']) #,**{'voltage':[\" IS NULL\"],}\n",
    "\n",
    "def mainRoads(osm_path):\n",
    "    \"\"\"\n",
    "    Function to extract main road linestrings from OpenStreetMap    \n",
    "    Arguments:\n",
    "        *osm_path* : file path to the .osm.pbf file of the region \n",
    "        for which we want to do the analysis.        \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with all unique main road linestrings.   \n",
    "    \"\"\" \n",
    "    return retrieve(osm_path,'lines',['highway','oneway','lanes','maxspeed'],**{'highway':[\"='primary' or \",\"='trunk' or \",\"='motorway' or \",\"='trunk_link' or \",\n",
    "                    \"='primary_link' or \", \"='secondary' or \",\"='tertiary' or \",\"='tertiary_link'\"]})\n",
    "\n",
    "\n",
    "def remove_overlap_openstreetmap(gdf):\n",
    "    \"\"\"\n",
    "    Function to remove overlap in polygons in from OpenStreetMap.\n",
    "    \n",
    "    Arguments:\n",
    "        *gdf* : a geopandas GeoDataFrame with all unique railway linestrings.\n",
    "        \n",
    "    Returns:\n",
    "        *GeoDataFrame* : a geopandas GeoDataFrame with (almost) non-overlapping polygons.\n",
    "    \n",
    "    \"\"\"\n",
    "    \n",
    "    gdf['sq_area'] = gdf.area\n",
    "\n",
    "    new_landuse = []\n",
    "    for use in tqdm(gdf.itertuples(index=False),total=len(gdf),desc='Get unique shapes'):\n",
    "        use_geom = use.geometry\n",
    "        matches = gdf.loc[list(gdf.sindex.intersection(use.geometry.bounds))]\n",
    "        for match in matches.itertuples(index=False):\n",
    "            if use.sq_area > match.sq_area:\n",
    "                use_geom = use_geom.difference(match.geometry)\n",
    "        new_landuse.append([use.osm_id,use.landuse,use_geom])\n",
    "\n",
    "    new_gdf  =  geopandas.GeoDataFrame(pandas.DataFrame(new_landuse,columns=['osm_id','landuse','geometry'])) \n",
    "    new_gdf.crs = {'init' : 'epsg:4326'}\n",
    "    return new_gdf\n",
    "\n",
    "\n",
    "def extract_value_other_gdf(x,gdf,col_name):\n",
    "    \"\"\"\n",
    "    Function to extract value from column from other GeoDataFrame\n",
    "    \n",
    "    Arguments:\n",
    "        *x* : row of main GeoDataFrame.\n",
    "        \n",
    "        *gdf* : geopandas GeoDataFrame from which we want to extract values.\n",
    "        \n",
    "        *col_name* : the column name from which we want to get the value.\n",
    "        \n",
    "    \n",
    "    \"\"\"\n",
    "    try:\n",
    "        return gdf.loc[list(gdf.sindex.intersection(x.geometry.bounds))][col_name].values[0]\n",
    "    except:\n",
    "        return None\n",
    "\n",
    "def get_losses(x,damage_curves,damage_values):\n",
    "    \"\"\"\n",
    "    Function to estimate the damages.\n",
    "    \n",
    "    Arguments:\n",
    "        *x* : row of main GeoDataFrame\n",
    "        \n",
    "        *damage_curves*: pandas DataFrame of curves. Inundation depths should be the index.\n",
    "        \n",
    "        *damage_values*: dictionary with maximum damage values.\n",
    "        \n",
    "    Returns:\n",
    "        \n",
    "        Total damage for the given land-use object.\n",
    "    \n",
    "    \"\"\"\n",
    "    \n",
    "    return numpy.interp(x.depth,list(damage_curves.index),list(damage_curves[x.landuse]))*damage_values[x.landuse]*x.area_m2"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
